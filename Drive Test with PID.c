#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     Right,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Left,          tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma DebuggerWindows("debugStream")
#include "drivers/PID.h"

void Drive(int distance);

task main()
{
	Drive(20);
}

void Drive(int distance)
{
	int C=2*(PI)*2;
	int Target= (1120/C)*distance;//en/in
	nMotorEncoder[motorE]=0;
	nMotorEncoder[motorD]=0;

		//motor[Left]= 100;
		//motor[Right]=100;
	while(true)
	{
	Motor[left]=PID(Target, nMotorEncoder[left]);//set one motor to Target
		writeDebugStreamLine("PID:%i, Target:%i,	Left:%i,	Right:%i",	PID(Target, nMotorEncoder[Left]),	Target,	-1*nMotorEncoder[Left],	nMotorEncoder[Right]);
	}
//Motor[Left]= PID( nMotorEncoder[Right], nMotorEncoder[Left]); //set the other as slave, one encoder will be backward, FIX ME
		//motor[Right]=PID(Target, nMotorEncoder[Left]);

		writeDebugStreamLine("PID:%i, Target:%i,	Left:%i,	Right:%i",	PID(Target, nMotorEncoder[Left]),	Target,	-1*nMotorEncoder[Left],	nMotorEncoder[Right]);

}
