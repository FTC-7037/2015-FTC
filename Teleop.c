#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     IRLeft,         sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     Compass,        sensorI2CHiTechnicCompass)
#pragma config(Sensor, S4,     HTSPB,          sensorI2CCustom9V)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     Right,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     Left,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     Intake,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     Hood,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     Conveyor,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     Lift,          tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    Gripper,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    lock,                 tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "drivers/HTSPB-driver.h"
#pragma DebuggerWindows("debugStream")
#define OPEN 0
#define CLOSED 1
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of tele-op mode, you may want to perform some initialization on your robot
// and the variables within your program.
//
// In most cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
	servo[Gripper]=0;
  return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the tele-op robot operation. Customize as appropriate for
// your specific robot.
//
// Game controller / joystick information is sent periodically (about every 50 milliseconds) from
// the FMS (Field Management System) to the robot. Most tele-op programs will follow the following
// logic:
//   1. Loop forever repeating the following actions:
//   2. Get the latest game controller / joystick settings that have been received from the PC.
//   3. Perform appropriate actions based on the joystick + buttons settings. This is usually a
//      simple action:
//      *  Joystick values are usually directly translated into power levels for a motor or
//         position of a servo.
//      *  Buttons are usually used to start/stop a motor or cause a servo to move to a specific
//         position.
//   4. Repeat the loop.
//
// Your program needs to continuously loop because you need to continuously respond to changes in
// the game controller settings.
//
// At the end of the tele-op period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
  initializeRobot();
  waitForStart();   // wait for start of tele-op phase
	int threshold = 14;
  while (true)
  {
  //driver 1
  	//drivetrain
		if(abs(joystick.joy1_y1)>threshold)
		{
		motor[Left]=joystick.joy1_y1;
		writeDebugStreamLine("Y1: %i", joystick.joy1_y1);
		}
		else
		{
		motor[Left]=0;
		}
		if(abs(joystick.joy1_y2)>threshold)
		{
		writeDebugStreamLine("Y2: %i", joystick.joy1_y2);
		motor[Right]=joystick.joy1_y2;
		}
		else
		{
		motor[Right]=0;
		}
		//Gripper-NC hold to CLOSED
		if(joy1Btn(8))
		{
		writeDebugStreamLine("joy1Btn(8): %i", joy1Btn(8));
		servo[Gripper]=245;
		}
		else
		{
		servo[Gripper]=0;
		}
		//lock
		if(joy1Btn(5))
		{
			servo[lock]=0;
		}
		else if(joy1Btn(7))
		{
		servo[lock]=255;
		}
		else
		{
		servo[lock]=127;
		}
// driver 2
		//intake- right trigger set
		if(joy2Btn(7))
		{
		writeDebugStreamLine("joy2Btn(6): %i", joy2Btn(6));
		motor[Intake]=80;
		}
		else if(joy2Btn(5))
		{
		writeDebugStreamLine("joy2Btn(8): %i", joy2Btn(8));
		motor[Intake]=-80;
		}
		else
		{
		motor[Intake]=0;
		}
		//Conveyor - left trigger set
		if(joy2Btn(6))
		{
		writeDebugStreamLine("joy2Btn(5): %i", joy2Btn(5));
		motor[Conveyor]=30;
		}
		else if(joy2Btn(8))
		{
		writeDebugStreamLine("joy2Btn(7): %i", joy2Btn(7));
		motor[Conveyor]=-30;
		}
		else
		{
		motor[Conveyor]=0;
		}
		//lift--3 up 2 down
		  int  Lim_base = HTSPBreadADC(HTSPB, 0, 10)>512;//boolean algebra.
		  int  Lim_top	= HTSPBreadADC(HTSPB, 1, 10)>512;//boolean algebra.
				if((Lim_top==OPEN && Lim_base==OPEN))//if neither switch is pressed
				{
					if(joy2Btn(3))//up
					{
						motor[Lift]=100;
					}
					else if(joy2Btn(2))//down
					{
						motor[Lift]=-100;
					}
					else
					{
						motor[Lift]=0;
					}
				}
				else if(Lim_top==CLOSED && Lim_base==OPEN)//if top is pressed->CLOSED
				{

					if(joy2Btn(2)) //only down
					{
						motor[Lift]=-100;
					}
					else
					{
						motor[Lift]=0;
					}
				}
				else if(Lim_top==OPEN && Lim_base==CLOSED)//if bottom is pressed->CLOSED
				{
					if(joy2Btn(3))//only up
					{
						motor[Lift]=100;
					}
					else
					{
						motor[Lift]=0;
					}
				}
		//hood-- 1 down 4 up
		if(joy2Btn(1))
		{
			writeDebugStreamLine("joy2Btn(1): %i", joy2Btn(1));
			motor[Hood]=30;
		}
		else if(joy2Btn(4))
		{
			writeDebugStreamLine("joy2Btn(4): %i", joy2Btn(4));
			motor[Hood]=-30;
		}
		else
		{
			motor[Hood]=0;
		}
		clearDebugStream();
	}
}
