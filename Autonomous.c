#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Sensor, S2,     IRLeft,         sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     Compass,        sensorI2CHiTechnicCompass)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     Right,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Left,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     Intake,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     none,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     Conveyor,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     Lift,          tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    Gripper,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    lock,                 tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma DebuggerWindows("debugStream")
#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "drivers/HTSPB-driver.h"
#define START_FLOOR  "FLOOR"
#define START_RAMP "RAMP"
#define TRUE 1
#define FALSE 0
#define MIN (X, Y) (((X)<(Y) ?(X) : (Y)
#define MAX (A, B) (((A)>(B) ?(X) : (Y)
string startPosition;
int GoalPosition =0;//must be initialized as zero so it can overide when/if LocateInfaRedBeacon() produces no change

task printf();
void getUserInput();
void initializeRobot();
void Routine1();
void Routine2();
void Routine3();
void RoutineERR();
void locateInfaRedBeacon();
void RunLift(float nStage);
void Drive(int distance);
void Turn(int Angle);// +360 to -360
void BumpConveyor();
void Test();
task main()
{
	startTask(printf);
	getUserInput();
	initializeRobot();
	//Test();
	waitForStart();
	locateInfaRedBeacon();//determins GoalPosition
}

task printf()
{
	while(true)
	{
	clearDebugStream();
	writeDebugStreamLine("startPosition: %s", startPosition);
	writeDebugStreamLine("GoalPosition: %i", GoalPosition);
	delay(100);
	clearDebugStream();
	}
}
void initializeRobot()
{
	servo[Gripper]=80;
	servo[lock]=127;
}
void getUserInput()
{
  nxtDisplayCenteredTextLine(1, "FLOOR or RAMP?");
  nxtDisplayCenteredTextLine(7, "FLOOR RAMP");
  while(true)
  {
    if(nNxtButtonPressed == 2)
    {
      startPosition = START_FLOOR;
      nxtDisplayCenteredTextLine(1, "FLOOR");
      nxtDisplayCenteredTextLine(7, "");
      break;
    }
    else if(nNxtButtonPressed == 1)
    {
      startPosition = START_RAMP;
      nxtDisplayCenteredTextLine(1, "RAMP");
      nxtDisplayCenteredTextLine(7, "");
      break;
    }
  }
  playSound(soundFastUpwardTones);
  wait10Msec(200);
  //bDisplayDiagnostics = false;
	nxtDisplayCenteredTextLine(0, "%s", startPosition);
}

void Routine1()
{
	if(startPosition==START_RAMP)
	{

	return;
	}
	else if(startPosition==START_FLOOR)
	{
	return;
	}
}


void Routine2()
{
	if(startPosition==START_RAMP)
	{

	return;
	}
	else if(startPosition==START_FLOOR)
	{
	return;
	}
}


void Routine3()
{
	if(startPosition==START_RAMP)
	{

	return;
	}
	else if(startPosition==START_FLOOR)
	{
	return;
	}
}

void RoutineERR()
{
	if(startPosition==START_RAMP)
	{

	return;
	}
	else if(startPosition==START_FLOOR)
	{
	return;
	}
}
void locateInfaRedBeacon()
{
//determine start Position(FLOOR=FLOOR, RAMP = ramp)
	if(startPosition == START_FLOOR)
	{
	//drive out of start Position and into GoalPosition_1
	}
	else if(startPosition == START_RAMP)
	{
	//drive out of start Position and into GoalPosition_1
	}

//if IR at GoalPosition 1 SET(int GoalPosition =1)and return;
	if(SensorValue[IRLeft]==5)
	{
	GoalPosition=1;
	return;
	}
//else drive out of GoalPosition1 and into GoalPosition_2


//check IR when robot has reached GoalPosition_2
//if IR at GoalPosition 2 SET(int GoalPosition =2)and return;
//else drive out of GoalPosition2 and into GoalPosition_3
//check IR when robot has reached GoalPosition_3
//if IR at GoalPosition 3 SET(int GoalPosition =1)and return;
}

void RunLift(float nStage)
{
 float Range=22.5;//mechanical rotations of the motor shaft to extend full length of lift
 float Stages=4;//number of stages
 float ppr= 1120;//pulse per revolution for the andymark motor
 float nTarget=(nStage/Stages)*(Range *ppr);
 float nFeedBack=(nMotorEncoder[Lift]/1120)/22.5*100;
 writeDebugStreamLine("Target: %f, nStage: %i", nTarget,nStage);//nStage is reading but nTarget is still 0???
 while(true)
 {
 // get last lift status
  float nStatus=(nMotorEncoder[Lift]/1120.0)/22.5*100.0;
  float mTarget=(((nStage/Stages)*(Range*ppr))/1120/22.5)*100;
  //should status change(how much)?
  if(mTarget<nStatus)
  {
  	while(nTarget<nStatus)
  	{
  		motor[Lift]=-100;
  	}
  }
  else if(mTarget>nStatus)
  {
  	while(mTarget>nStatus)
  	{
  		motor[Lift]=100;
  	}
  }
  //are we there yet? if(Target>position) move towards target else{stop and break;}
 }

 if(nTarget>1)//run up
 {
		while(nMotorEncoder[Lift]<=nTarget)
		{
		float nFeedBack=(nMotorEncoder[Lift]/1120)/22.5;
		writeDebugStreamLine("Value :%f Target: %f, Location: %f", nMotorEncoder[Lift], nTarget, nFeedBack);
		motor[Lift]=75;
		}
		float nFeedBack=(nMotorEncoder[Lift]/1120)/22.5;
		writeDebugStreamLine("Value :%f Target: %f, Location: %f", nMotorEncoder[Lift], nTarget, nFeedBack);
		motor[Lift]=0;
	}
	if(nTarget<1)//run down
	{
		while(nMotorEncoder[Lift]>=nTarget)//if switch is pressed break...
		{
		writeDebugStreamLine("Value :%i, Target: %i", nMotorEncoder[Lift], nTarget);
		motor[Lift]=-75;
		}
		motor[Lift]=0;
	}
}

void Drive(int distance)
{
	int C=2*(PI)*2;
	int Target= (1120/C)*distance;//en/in
	nMotorEncoder[motorE]=0;
	if(distance>1)
	{
		while(nMotorEncoder[motorE]<=Target)
		{
		writeDebugStreamLine("Value :%i, Target: %i",nMotorEncoder[motorE], Target);
		}
		motor[motorD]=0;
		motor[motorE]=0;
	}
	else if(distance<1)
	{
		while(nMotorEncoder[motorE]>=Target)
		{
		writeDebugStreamLine("Value :%i, Target: %i",nMotorEncoder[motorE], Target);
		motor[motorD]=-75;
		motor[motorE]=-75;
		}
		motor[motorD]=0;
		motor[motorE]=0;
	}
}
void Turn(int Angle)//clockwise is negitive
{

	float circumfrence = 2*(PI)*2;
	int ppr = 1120;
	int enc_in=ppr/circumfrence;//result

	float WheelbaseRadius = 7.3875;
	float ArcLength=degreesToRadians(Angle)*WheelbaseRadius;//result

	int Target= round(ArcLength*enc_in);//goal

	writeDebugStreamLine("Target:%i",Target);
  nMotorEncoder[motorE]=0;
  nMotorEncoder[motorD]=0;
  //1/2 rot= 45deg = 1120enc
	if(Angle<1)
	{
	//left
		while(nMotorEncoder[motorE]>= Target)
		{
		motor[Right]=100;
		motor[Left]=-100;
		}
		motor[Right]=0;
		motor[Left]=0;
	}
	else if(Angle>1)
	{
	//right
		while(nMotorEncoder[motorE]<= Target)
		{
		motor[Right]=-100;
		motor[Left]=100;
		}
		motor[Right]=0;
		motor[Left]=0;
	}
}
void BumpConveyor()
{
motor[Conveyor]=75;
wait10Msec(100);
motor[Conveyor]=0;
wait10Msec(50);
motor[Conveyor]=75;
wait10Msec(0.75);
motor[Conveyor]=0;
}
void Test()
{
  float nFeedBack=((23000/1120.0)/22.5)*100;
  writeDebugStreamLine("Status:%f",nFeedBack);
}
