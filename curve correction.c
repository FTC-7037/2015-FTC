#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     Gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     light,          sensorLightActive)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
#pragma config(Motor,  mtr_S1_C1_1,     rightMotor,    tmotorTetrix, openLoop, reversed, driveRight, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     leftMotor,     tmotorTetrix, openLoop, driveLeft, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma DebuggerWindows("debugStream")
//nMotorPIDSpeedCtrl[Right] = mtrSpeedReg;  // enable PID
//nMotorPIDSpeedCtrl[Left] = mtrSpeedReg;  // enable PID
#define MIN(a,b) (((a)<(b))?(a):(b))
#define MAX(a,b) (((a)>(b))?(a):(b))
float map(float x, float in_min, float in_max, float out_min, float out_max)
{
return (x-in_min)*(out_max-out_min)/(in_max- in_min)+ out_min;
}
	void SetSpeed(int Leftspeed, int Rightspeed)
	{
		//Leftspeed=map(Leftspeed,-100,100,-78,78);//for use with built in PID
		//Rightspeed=map(Rightspeed,-100,100,-78,78);//for use with built in PID
	motor[leftMotor]=Leftspeed;
	motor[rightMotor]=Rightspeed;
	}

	void Drive(float outputMagnitude, float curve)//(-1,+1) all
 {
     float leftOutput, rightOutput=0.0;
     float m_sensitivity=0.3;//tuning value KP
     float value=0;
     float ratio=0;
     if (curve < 0)
     {
              value = log(-1*curve);
              ratio = (value - m_sensitivity)/(value + m_sensitivity);
             if (ratio == 0) ratio =.0000000001;
             leftOutput = outputMagnitude ;
             rightOutput = outputMagnitude/ ratio;
     }
     else if (curve > 0)
     {
              value = log(curve);
              ratio = (value - m_sensitivity)/(value + m_sensitivity);
             if (ratio == 0) ratio =.0000000001;
             leftOutput = outputMagnitude / ratio;
             rightOutput = outputMagnitude;
     }
     else
     {
             leftOutput = outputMagnitude;
             rightOutput = outputMagnitude;
     }
     SetSpeed(round(leftOutput*100), round(rightOutput*100));//(-100, +100)
     writeDebugStreamLine(" curve:%f, leftOutput:%f, rightOutput:%f, value:%f, ratio:%f ",curve, round(leftOutput*100), round(rightOutput*100), value, ratio);
 }
void Drive(int Distance)//working virtual *5/4/15*
{

	/****************************************************************************************
	this function is meant to correct for drift using a proportional controller.(P) from PID.
	If properly used the funtion WILL correct for minor drift Within 1/100degree acuracy.
	****************************************************************************************/
	//constants used to compute drift
		float speed = 0.5;
	  float Angle=0;// what we will use to hold angle during our loop
	  float Kp =1.25;//gain, rate of change, 0-100.
	  float WheelbaseRadius = 6.69;//Robot virtual worlds "conveyor bot"
		// float WheelbaseRadius = 7.3875;// Robot: Team #7037 "Ada" 2015

	//calculate encoder target from distance
		float C=2*(PI)*2;//wheel circumfrence
		int ppr =1120;
		float enc_in=ppr/C;
		int	Target =enc_in*Distance;//encoder target counts

	//used for orientation
		int direction=0;
		int ProcessValue=0;
		//reset encoderes
		nMotorEncoder[leftMotor]=0;
		nMotorEncoder[rightMotor]=0;
	//determine orintetion
	if(Distance>0)//forward
	{
		while(Target>ProcessValue)//will change to (target<processvalue)
		{
			//update and adjust encoders
			int Lenc= -1* nMotorEncoder[leftMotor];
			int Renc= -1* nMotorEncoder[rightMotor];
			ProcessValue= Lenc+Renc/2;//average distace traveled
			//writeDebugStreamLine("Lenc: %i, Renc: %i", Lenc,Renc);//check to make sure both encoderds positating, sanity check
		//check for deviation
			if(Lenc>Renc)//veering right
			{
				direction=1;//poitive
			}
			else if(Lenc<Renc)//veering left
			{
				direction=-1;//negitive
			}
		//find angle of deviation
			int Y=round(enc_in*(MAX(Lenc, Renc)-MIN(Lenc, Renc)));//the difference between encoders
			int H=WheelbaseRadius*2;//distance between wheels
			int X=sqrt(Y^2+H^2)*direction;//how far deviated in what direction (not entirely true but close enough)
			float preangle=sinDegrees(X/H);//will later be used for porportional control
	 		Angle= map(preangle,0,0.9,0,187);//for humans
	 		writeDebugStreamLine("angle:%f, preangle:%f", Angle, preangle);//for humans
	 	//start moving and correct for drift porportionaly using angle
			Drive(speed,preangle*Kp);//this is basic porportional control
		}//end of loop
	}
	if(Distance<0)//reverse
	{
	//needs to be written...
	}
}//end of funtion

task main()
{
clearDebugStream();
Drive(10);
}
//Drive(10);
