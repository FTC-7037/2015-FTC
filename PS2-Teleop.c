#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     IRLeft,         sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     PSPNX,          sensorI2CCustomFastSkipStates)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     Right,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Left,          tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     Intake,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     Hood,          tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_1,     Conveyor,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     Lift,          tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    Gripper,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    lock,                 tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of tele-op mode, you may want to perform some initialization on your robot
// and the variables within your program.
//
// In most cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
#include "PSP-Nx-lib.h"
const ubyte Addr = 0x02;
void initializeRobot()
{
	servo[Gripper]=0;
  return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the tele-op robot operation. Customize as appropriate for
// your specific robot.
//
// Game controller / joystick information is sent periodically (about every 50 milliseconds) from
// the FMS (Field Management System) to the robot. Most tele-op programs will follow the following
// logic:
//   1. Loop forever repeating the following actions:
//   2. Get the latest game controller / joystick settings that have been received from the PC.
//   3. Perform appropriate actions based on the joystick + buttons settings. This is usually a
//      simple action:
//      *  Joystick values are usually directly translated into power levels for a motor or
//         position of a servo.
//      *  Buttons are usually used to start/stop a motor or cause a servo to move to a specific
//         position.
//   4. Repeat the loop.
//
// Your program needs to continuously loop because you need to continuously respond to changes in
// the game controller settings.
//
// At the end of the tele-op period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{

  initializeRobot();
 // waitForStart();   // wait for start of tele-op phase
   psp cuRrState;
   bool smartOverride=false;
   bool pressed=false;
	nI2CBytesReady[PSPNX] = 0;
	PlaySound(soundUpwardTones);//confirm initialization;
	int threshold = 14;
  while (true)
  {
  	  	//register new inputs
  	PSP_ReadButtonState(PSPNX, Addr, cuRrState);//instantiate new controller "class"
		bool joy1Btn_1								= !(char)cuRrState.square;//hood down
		bool joy1Btn_2								= !(char)cuRrState.cross; //lift down
		bool joy1Btn_3								= !(char)cuRrState.circle;//lift up
		bool joy1Btn_4								= !(char)cuRrState.triang;//hood up
		bool joy1Btn_5								= !(char)cuRrState.d;			//unused
		bool joy1Btn_6								= !(char)cuRrState.c;			//unused
		bool joy1Btn_7								= !(char)cuRrState.b;			//unused
		bool joy1Btn_8								= !(char)cuRrState.a;			//unused
		bool joy1Btn_9								= !(char)cuRrState.l1;		//manip up
		bool joy1Btn_10								= !(char)cuRrState.r1;		//intake in
		bool joy1Btn_11								= !(char)cuRrState.l2;		//manip down
		bool joy1Btn_12								= !(char)cuRrState.r2;		//intake out
		bool joy1Btn_13								= !(char)cuRrState.l_j_b; //unused
		bool joy1Btn_14								= !(char)cuRrState.r_j_b; //unused
		int joystick_joy1_x1					= (int)cuRrState.l_j_x;		//unused(-100)-(100)
		int joystick_joy1_y1					= (int)cuRrState.l_j_y;		//left motor(-100)-(100)
		int joystick_joy1_x2					= (int)cuRrState.r_j_x;		//unused(-100)-(100
		int joystick_joy1_y2					= (int)cuRrState.r_j_y;		//right motor(-100)-(100)
  //create output logic(physical actuation)
	//choose Mode
					if(joy1Btn_7) { // when we press the switch for the first time,
				if(!pressed) { // set as pressed
					if(smartOverride==true) { // when we press it again, it gets turned off
						smartOverride=false;
					} else {
						smartOverride =true;
					}
				}
				pressed = true; // keeping track of pressed allows the button to be
			} else { // held down
			pressed = false;
			}
		//!Kid Mode!
			if(smartOverride==false)
			{
			 	//+drivetrain
					if(abs(joystick_joy1_y1)>threshold)
					{
					motor[Left]=joystick_joy1_y1;
					writeDebugStreamLine("Y1: %i", joystick_joy1_y1);
					}
					else
					{
					motor[Left]=0;
					}
					if(abs(joystick_joy1_y2)>threshold)
					{
					writeDebugStreamLine("Y2: %i", joystick_joy1_y2);
					motor[Right]=joystick_joy1_y2;
					}
					else
					{
					motor[Right]=0;
					}
			}
		//APO
		if(smartOverride==true)
		{
	  //driver 1
	  	//+drivetrain
			if(abs(joystick_joy1_y1)>threshold)
			{
			motor[Left]=joystick_joy1_y1;
			writeDebugStreamLine("Y1: %i", joystick_joy1_y1);
			}
			else
			{
			motor[Left]=0;
			}
			if(abs(joystick_joy1_y2)>threshold)
			{
			writeDebugStreamLine("Y2: %i", joystick_joy1_y2);
			motor[Right]=joystick_joy1_y2;
			}
			else
			{
			motor[Right]=0;
			}
			//Gripper-NC hold to open
			//if(joy1Btn(8))
			//{
			//writeDebugStreamLine("joy1Btn(8): %i", joy1Btn(8));
			//servo[Gripper]=245;
			//}
			//else
			//{
			//servo[Gripper]=0;
			//}
			////lock
			//if(joy1Btn(5))
			//{
			//	servo[lock]=0;
			//}
			//else if(joy1Btn(7))
			//{
			//servo[lock]=255;
			//}
			//else
			//{
			//servo[lock]=127;
			//}
	// driver 2
			//intake- right trigger set
			if(joy1Btn_12)
			{
		//	writeDebugStreamLine("joy1Btn(6): %i", joy1Btn(6));
			motor[Intake]=80;
			}
			else if(joy1Btn_10)
			{
		//	writeDebugStreamLine("joy1Btn(8): %i", joy1Btn(8));
			motor[Intake]=-80;
			}
			else
			{
			motor[Intake]=0;
			}
			//Conveyor - left trigger set
			if(joy1Btn_9)
			{
		//	writeDebugStreamLine("joy1Btn(5): %i", joy1Btn(5));
			motor[Conveyor]=75;
			}
			else if(joy1Btn_11)
			{
		//	writeDebugStreamLine("joy1Btn(7): %i", joy1Btn(7));
			motor[Conveyor]=-75;
			}
			else
			{
			motor[Conveyor]=0;
			}
			//lift--3 up 2 down
			if(joy1Btn_3)
			{
		//		writeDebugStreamLine("joy1Btn(3): %i", joy1Btn(3));
			motor[Lift]=100;
			}
			else if(joy1Btn_2)
			{
		//	writeDebugStreamLine("joy1Btn(2): %i", joy1Btn(2));
			motor[Lift]=-100;
			}
			else
			{
				motor[Lift]=0;
			}
			//hood-- 1 down 4 up
			if(joy1Btn_1)
			{
		//		writeDebugStreamLine("joy1Btn(1): %i", joy1Btn(1));
				motor[Hood]=30;
			}
			else if(joy1Btn_4)
			{
			//	writeDebugStreamLine("joy1Btn(4): %i", joy1Btn(4));
				motor[Hood]=-30;
			}
			else
			{

				motor[Hood]=0;
			}
			clearDebugStream();
		}
	}
}
